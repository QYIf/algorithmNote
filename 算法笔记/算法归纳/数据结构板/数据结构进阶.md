# 数据结构进阶

## 可持续化Trie树

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 600010, M = N * 25;

int tr[M][2], root[N], idx;
int n, m, tmp, s[N], mxi[M];
int l, r, x;
char op;

void insert(int i, int k, int p, int q) {
    if(k < 0) {
        mxi[q] = i;
        return;
    }
    int v = s[i] >> k & 1;
    if(p) tr[q][v ^ 1] = tr[p][v ^ 1];
    tr[q][v] = ++idx;
    insert(i, k - 1, tr[p][v], tr[q][v]);
    mxi[q] = max(mxi[tr[q][0]], mxi[tr[q][1]]);
}

int ask(int rt, int num, int l) {
    int cur = rt;
    for(int i = 23; i >= 0; i--) {
        int v = num >> i & 1;
        if(mxi[tr[cur][v ^ 1]] >= l) cur = tr[cur][v ^ 1];
        else cur = tr[cur][v];
    }
    return num ^ s[mxi[cur]];
}

int main() {
    scanf("%d%d", &n, &m);
    mxi[0] = -1;
    root[0] = ++idx;
    insert(0, 23, 0, root[0]);
    for(int i = 1; i <= n; i++) {
        scanf("%d", &x);
        s[i] = s[i - 1] ^ x;
        root[i] = ++idx;
        insert(i, 23, root[i - 1], root[i]);
    }
    while(m--) { 
        scanf(" %c", &op);
        if(op == 'A') {
            scanf("%d", &x);
            n++;
            s[n] = s[n - 1] ^ x;
            root[n] = ++idx;
            insert(n, 23, root[n - 1], root[n]);
        } else {
            scanf("%d%d%d", &l, &r, &x);
            printf("%d\n", ask(root[r - 1], s[n] ^ x, l - 1));
        }
    }
    return 0;
}
```

## 可持续化线段树 (主席树)

```cpp

```

## 平衡树

### (1) Treap

```cpp

```

### (2) splay

```cpp

```

## 分块

```cpp

```

## 莫队 

```cpp

```