# Codeforces Round #565 (Div. 3)

## A. Divide it!

```c++
    #include<bits/stdc++.h>
    #define ll long long
    const int N= 200010;
    using namespace std;

    int main() {
    	ll t,num,ans;
    	cin>>t;
    	while(t--) {
    		ans=0;
    		cin>>num;
    		while(num%5==0) {
    			num/=5;
    			ans+=3;
    		}
    		while(num%3==0) {
    			num/=3;
    			ans+=2;
    		}
    		while(num%2==0) {
    			num/=2;
    			ans++;
    		}
    		if(num==1)
    			cout<<ans<<endl;
    		else
    			cout<<-1<<endl;
    	}
    	return 0;
    }
```

> 这道题目的思路是首先对这些数字操作，对于第一种就相当于把每个数除以 2，操作一次。对于第二种则是把每个数除以 3 再除以 2，每次操作 2 次。第三种则是把每个数操作 3 次，即使除以 5，除以 2 再除以 2。把每个操作执行完后看是否结果为 1，是则输出操作次数，否则输出-1。

## B. Merge it!

```c++
        #include<bits/stdc++.h>
    #define ll long long
    const int N= 200010;
    using namespace std;
    ll l[N];

    int main() {
    	ios::sync_with_stdio(false);
    	cin.tie(0);
    	cout.tie(0);
    	ll t,n,ans,num,tmp;
    	cin>>t;
    	while(t--) {
    		memset(l,0,sizeof(l));
    		cin>>n;
    		for(int i=0; i<n; i++) {
    			cin>>num;
    			tmp=num%3;
    			l[tmp]++;
    		}
    		if(l[1]>l[2])
    			ans=l[0]+l[2]+(l[1]-l[2])/3;
    		else
    			ans=l[0]+l[1]+(l[2]-l[1])/3;
    		cout<<ans<<endl;
    	}
    	return 0;
    }
```

> 这道题的主要思路是将所有数字对 3 取模，然后统计各各余数的个数，最终的答案则输出余数为零的个数加上余数为 1 与 2 中较小的一个的数量，最后把剩余的数（1 或 2）/3 加入答案中。

## C. Lose it!

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=500010;
int n,a[N],ans,sum[50];
int main() {
	scanf("%d",&n);
	for (int i=0; i<n; i++) {
		scanf("%d",&a[i]);
		if (a[i]==4)
			sum[4]++;
		else if (a[i]==8 && sum[4]) {
			sum[4]--;
			sum[8]++;
		} else if (a[i]==15 && sum[8]) {
			sum[8]--;
			sum[15]++;
		} else if (a[i]==16 && sum[15]) {
			sum[15]--;
			sum[16]++;
		} else if (a[i]==23 && sum[16]) {
			sum[16]--;
			sum[23]++;
		} else if (a[i]==42 && sum[23]) {
			sum[23]--;
			ans++;
		}
	}
	printf("%d\n",n-6*ans);
	return 0;
}
```

> 这道题的主要思路是遍历一遍，用一个数组记录下 4，8，15，16，23 的个数，如果有 4 则 4 的数量++，其他的数都要看看前面有没有才进行++，例如，前面有 4，8 才++，前面有 8，15 才++以次类推。最终如果按顺序存好了每一个数，则 ans++，最终输出答案。

## D. Recover it!

```c++
    #include<bits/stdc++.h>
    using namespace std;
    const int N=2750132;
    bool isprime[N];
    int prime[N],cnt,pos[N],num,a[N];
    priority_queue<int> q;
    vector<int> ans;
    //素数筛+pos存储
    void oulashai() {
    	for(int i=2; i<=N; i++) {
    		if(!isprime[i]) prime[++cnt]=i,pos[i]=cnt;
    		for(int j=1; j<=cnt&&i*prime[j]<=N; j++) {
    			isprime[i*prime[j]]=1;
    			if(i%prime[j]==0) break;
    		}
    	}
    }
    //查找当前数的最大因子
    int maxdiv(int x) {
    	for(int i=2; i*i<=x; ++i)
    		if(x%i==0) return x/i;
    }

    int main() {
    	oulashai();
    	int n;
    	cin>>n;
    	for(int i=0; i<n*2; i++) {
    		cin>>num;
    		q.push(num);
    	}
    	while(!q.empty()) {
    		int cur=q.top();
    		q.pop();
            //检测该数是否需要删去
    		if(a[cur]>0)
    			a[cur]--;
    		else {
    			if(!isprime[cur]) {
                    //是素数则把该数的位置放入ans中
    				ans.push_back(pos[cur]);
                    //标记之后遇到该数要删除
    				a[pos[cur]]++;
    			} else {
                    //是合数则把该数放入ans中
    				ans.push_back(cur);
                    //标记之后遇到该数的最大因子要删除
    				a[maxdiv(cur)]++;
    			}
    		}
    	}
        //输出答案
    	for(int i=0; i<ans.size(); i++)
    		cout<<ans[i]<<" ";
    	return 0;
    }
```

> 这道题基本的思路是从大到小，遇到素数时，把素数删，然后把一个表示该素数在当前哪一位的数字存入 ans 中，如果后面遇到了一个该数要删去。遇到一个合数的时，就把当前合数存入 ans 中，然后后续遇到该合数的最大因子时，把该数字删去。

## E. Cover it!

1. 第一次代码(BFS)超时了

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=2750132;
bool used[N];
vector<int> enodes;
vector<int> onodes;
vector<int> num[N];
struct node {
	int dot,iso;
};

void bfs(int x) {
	queue<node> q;
	node start;
	start.dot=x;
	start.iso=1;
	q.push(start);
	used[x]=1;
	while(!q.empty()) {
		node cur=q.front();
		if(cur.iso==0)
			enodes.push_back(cur.dot);
		else
			onodes.push_back(cur.dot);
		q.pop();
		for(int i=0; i<num[cur.dot].size(); i++) {
			if(used[num[cur.dot][i]]==0) {
				used[num[cur.dot][i]]=1;
				node news;
				news.dot=num[cur.dot][i];
				news.iso=cur.iso==0?1:0;
				q.push(news);
			}
		}
	}
}

int main() {
	int t;
	cin>>t;
	while(t--) {
		int n,m,s,e;
		cin>>n>>m;
		for(int i=0; i<=n; i++) {
			num[i].clear();
		}
		enodes.clear();
		onodes.clear();
		memset(used,0,sizeof(used));
		for(int i=0; i<m; i++) {
			cin>>s>>e;
			num[s].push_back(e);
			num[e].push_back(s);
		}
		bfs(1);
		if(enodes.size()>onodes.size()) {
			cout<<onodes.size()<<endl;
			for(int i=0; i<onodes.size(); i++) {
				cout<<onodes[i]<<" ";
			}
			cout<<endl;
		} else {
			cout<<enodes.size()<<endl;
			for(int i=0; i<enodes.size(); i++) {
				cout<<enodes[i]<<" ";
			}
			cout<<endl;
		}
	}
	return 0;
}
```

2. 第二次代码(DFS)

```c++

```

>
