# dp每日打卡

## 困难题

### 2月1日

#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

```cpp
/*
大致思路：
这道题是实现一个正则匹配的功能
这道题可以使用一个二维数组来存下当前状态然后逐步递推
首先二维的数组中横坐标对应的是模式串，而纵坐标对应的是字符串
然后每次进行判定，判定情况如下：
1. 如果模式串的当前位置为正常的字符那么看看当前字符是否与对应字符匹配，
匹配则看看前面的字符是否匹配，
都匹配则标记当前匹配否则标记不匹配
2. 如果模式串的当前位置为'.'，那么只要只要前面的字符串匹配则当前位置匹配
3. 如果模式串的当前位置是'*'，那么分两种情况：
1）其对应的字符前面已经匹配了dp[i][j - 2] == 1，那么就可以匹配（其对应的字符一个也不出现）
2）其对应的字符前面不匹配那么我们看看当前对应字符与字符串中的对应字符是否匹配，
匹配则看看上次匹配是否成功，成功则标记当前位置匹配
*/
class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.size(), m = p.size();
        vector<vector<bool> > dp(n + 1, vector<bool>(m + 1, 0));
        dp[0][0] = 1;
        //初始化第一行的值
        for(int j = 1; j <= m; j++) {
            if(j > 1) {
                if(p[j - 1] == '*') dp[0][j] = dp[0][j - 2];
                else dp[0][j] = 0;
            } else {
                if(p[j - 1] == '*') dp[0][j] = 1;
                else dp[0][j] = 0;
            }
        }
        //推导后面的情况
        for(int i = 1; i < n + 1; i++) {
            for(int j = 1; j < m + 1; j++) {
                //*的情况下
                if(p[j - 1] == '*') {
                    //*不应该出现在第一位如果出现在第一位dp默认为0
                    if(j > 1) {
                        if(dp[i][j - 2]) dp[i][j] = 1;
                        else {
                            if(s[i - 1] == p[j - 2] || p[j - 2] == '.') dp[i][j] = dp[i - 1][j];
                            else dp[i][j] = 0;
                        }
                    }
                //如果是.的情况下
                //如果是正常字符的情况下
                } else if(p[j - 1] == '.' || s[i - 1] == p[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 0;
                }
            }
        }
        return dp[n][m];
    }
};
```



#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

```CPP
/*
基本思路：
这道题首先我们要分析一下怎样匹配
当是左括号是没什么好说的没有与之匹配的右括号，所以dp值为0
只有访问到右括号时我们才会去寻找那个与之匹配的左括号
匹配方法就是首先找到一个可以与之匹配的左括号，
找的方法就是先看看前面的dp值，前面的dp值可以使得我们跳过已经匹配好的括号，直接找到最外层
如果最外层（包裹内层）的括号匹配，则相当于在已经匹配好的部分外面再套一层
【例如】：(()()()((())))最外层的即为我们想匹配的东西
当匹配完后我们再看看我们
*/
class Solution {
public:
    int longestValidParentheses(string s) {
        vector<int> dp(s.size() + 1, 0);
        int mx = 0;
        for(int i = 1; i < s.size(); i++) {
            //出现了右括号则开始进行更新
            if(s[i] == ')') {
                //判断当前右括号匹配到的位置是否越界
                if(i - dp[i - 1] - 1 < 0) dp[i] = 0;
                else {
                    int idx = i - dp[i - 1] - 1;
                    //看看匹配的位置是否为左括号
                    if(s[idx] == '(') {
                        //匹配成功后相当于在原来的基础上又套了一层
                        dp[i] = dp[i - 1] + 2;
                        //看看前面的括号是否匹配，匹配则把前面的长度加上
                        if(idx - 1 > 0) dp[i] += dp[idx - 1];
                    }
                }
            }
            //在求dp的同时
            mx = max(mx, dp[i]);
        }
        return mx;
    }
};
```

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

```CPP
/*
基本思路：
这道题的思路比较神奇确实想不到
首先从左往右用一个数组来维护一个高度的最大值
然后从右往左用一个数组来维护一个高度的最小值
然后从右往左找到左右中的最小值，然后判断当前挡板与最小值间的关系
如果小于则说明则是该位置会形成凹槽，那么该位置就可以装入雨水
*/
class Solution {
public:
    int trap(vector<int>& h) {
        if (h.size() == 0) return 0;
        int ans = 0;
        int n = h.size();
        vector<int> lmx(n), rmx(n);
        lmx[0] = h[0];
        rmx[n - 1] = h[n - 1];
        //从左往右用一个数组来维护一个高度的最大值
        for (int i = 1; i < n; i++) lmx[i] = max(h[i], lmx[i - 1]);
        //从右往左用一个数组来维护一个高度的最小值
        for (int i = n - 2; i >= 0; i--) rmx[i] = max(h[i], rmx[i + 1]);
        //把所有能装入的雨水加入到答案中
        for (int i = 1; i < n - 1; i++) ans += min(lmx[i], rmx[i]) - h[i];
        return ans;
    }
};
```

### 2月2日

#### 